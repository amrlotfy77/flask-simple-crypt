"""
    flask-simple-crypt
    ------------------

    A Flask extension providing simple, secure encryption and decryption for Python.
    Original work and credit goes to Andrew Cooke, https://github.com/andrewcooke/simple-crypt

    :copyright: (c) 2016 by Carlos Rivas, carlos@twobitcoder.com
                (c) 2012-2015 Andrew Cooke, andrew@acooke.org
                (c) 2013 d10n, https://github.com/d10/ & david@bitinvert.com

    :license: MIT, see LICENSE for more details.

"""

__version_info__ = ("0", "1", "0")
__version__ = ".".join(__version_info__)
__author__ = "Carlos Rivas"
__license__ = "BSD"
__copyright__ = "(c) 2016 by Carlos Rivas\n" \
                "(c) 2012-2015 Andrew Cooke\n" \
                "(c) 2013 d10n, https://github.com/d10/\n" \
                "               david@bitinvert.com"
__all__ = ["encrypt", "decrypt"]

from Crypto.Cipher import AES
from Crypto.Hash import SHA256, HMAC
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Random.random import getrandbits
from Crypto.Util import Counter

EXPANSION_COUNT = 2000  # <-- handles how many rounds
AES_KEY_LEN = 256
SALT_LEN = 256
HASH = SHA256
PREFIX = b"fsc"
HEADER = PREFIX + b"\x00\x02"
HALF_BLOCK = AES.block_size * 8 // 2
HEADER_LEN = len(HEADER)


def encrypt(password, data):
    data = _str_to_bytes(data)
    _assert_encrypt_length(data)
    salt = bytes(_random_bytes(SALT_LEN // 8))
    hmac_key, cipher_key = _expand_keys(password, salt, EXPANSION_COUNT)
    counter = Counter.new(HALF_BLOCK, prefix=salt[:HALF_BLOCK // 8])
    cipher = AES.new(cipher_key, AES.MODE_CTR, counter=counter)
    encrypted = cipher.encrypt(data)
    hmac = _hmac(hmac_key, HEADER + salt + encrypted)
    return HEADER + salt + encrypted + hmac


def decrypt(password, data):
    _assert_not_unicode(data)
    _assert_header_prefix(data)
    _assert_decrypt_length(data)
    raw = data[HEADER_LEN:]
    salt = raw[:SALT_LEN // 8]
    hmac_key, cipher_key = _expand_keys(password, salt, EXPANSION_COUNT)
    hmac = raw[-HASH.digest_size:]
    hmac2 = _hmac(hmac_key, data[:-HASH.digest_size])
    _assert_hmac(hmac_key, hmac, hmac2)
    counter = Counter.new(HALF_BLOCK, prefix=salt[:HALF_BLOCK // 8])
    cipher = AES.new(cipher_key, AES.MODE_CTR, counter=counter)
    return cipher.decrypt(raw[SALT_LEN // 8:-HASH.digest_size])


class DecryptionException(Exception): pass


class EncryptionException(Exception): pass


def _assert_not_unicode(data):
    u_type = type(b"".decode("utf8"))
    if isinstance(data, u_type):
        raise DecryptionException("Data to decrypt must be bytes; " +
                                  "you cannot use a string because " +
                                  "no string encoding will accept all " +
                                  "possible characters.")


def _assert_encrypt_length(data):
    if len(data) > 2 ** HALF_BLOCK:
        raise EncryptionException("Message too long.")


def _assert_decrypt_length(data):
    if len(data) < HEADER_LEN + SALT_LEN // 8 + HASH.digest_size:
        raise DecryptionException("Missing data.")


def _assert_header_prefix(data):
    if len(data) >= 3 and data[:3] != PREFIX:
        raise DecryptionException("Data passed to decrypt were not generated by simple-crypt (bad header).")


def _assert_hmac(key, hmac, hmac2):
    if _hmac(key, hmac) != _hmac(key, hmac2):
        raise DecryptionException("Bad password or corrupt / modified data.")


def _pbkdf2(password, salt, n_bytes, count):
    return PBKDF2(password, salt, dkLen=n_bytes,
                  count=count, prf=lambda p, s: HMAC.new(p, s, HASH).digest())


def _expand_keys(password, salt, expansion_count):
    if not salt: raise ValueError("Missing salt.")
    if not password: raise ValueError("Missing password.")
    key_len = AES_KEY_LEN // 8
    keys = _pbkdf2(_str_to_bytes(password), salt, 2 * key_len, expansion_count)
    return keys[:key_len], keys[key_len:]


def _hide(ranbytes):
    return bytearray(_pbkdf2(bytes(ranbytes), b"", len(ranbytes), 1))


def _random_bytes(n):
    return _hide(bytearray(getrandbits(8) for _ in range(n)))


def _hmac(key, data):
    return HMAC.new(key, data, HASH).digest()


def _str_to_bytes(data):
    u_type = type(b"".decode("utf8"))
    if isinstance(data, u_type):
        return data.encode("utf8")
    return data
